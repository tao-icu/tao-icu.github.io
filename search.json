[{"title":"正则表达式","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","categories":[["java","/categories/java/"]],"content":"规则**.** - 除换行符以外的所有字符。 **^** - 字符串开头。 **$** - 字符串结尾。 \\d,\\w,\\s - 匹配数字、字符、空格。 \\D,\\W,\\S - 匹配非数字、非字符、非空格。 **[abc]** - 匹配 a、b 或 c 中的一个字母。 **[a-z]** - 匹配 a 到 z 中的一个字母。 **[^abc]** - 匹配除了 a、b 或 c 中的其他字母。 **aa|bb** - 匹配 aa 或 bb。 **?** - 0 次或 1 次匹配。 ***** - 匹配 0 次或多次。 **+** - 匹配 1 次或多次。 **&#123;\\*n\\*&#125;** - 匹配 n次。 **&#123;\\*n\\*,&#125;** - 匹配 n次以上。 **&#123;\\*m\\*,\\*n\\*&#125;** - 最少 m 次，最多 n 次匹配。 (*expr*) - 捕获 expr 子模式,以 \\1 使用它。 (?:*expr*) - 忽略捕获的子模式。 (?=*expr*) - 正向预查模式 expr。 (?!*expr*) - 负向预查模式 expr。 工具： []: "},{"title":"定时任务","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","categories":[["框架相关","/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"]],"content":"在线生成 corn 表达式  启动类添加： 定时任务 corn表达式 形式 * * * * * * 字段 Seconds Minutes Hours DayofMonth Month DayofWeek 含义 秒 分 时 日 月 星期 范围 0-59 0-59 0-23 1-31 1-12 1-7 符号 ，-*&#x2F; ，-*&#x2F; ，-*&#x2F; ，-*&#x2F; ？L W C ，-*&#x2F; ，-*&#x2F; ? L C # , :表示列出枚举值。如：在分钟 5，20 表示在第 5分钟 和第20分钟 -在 秒上表示 5秒和20秒 -：表示范围 。 5-20 在5-20分钟，每分钟都会触发事件。 *：表示任意值。在分钟上 表示每分钟都执行 &#x2F;：表示起始时间开始触发 ，每间隔时间继续触发 2&#x2F;20 第二分钟触发 22分钟触发 ？：用在 日 和 星期 为防止冲突 其中一个为 ? L:表示最后 只能出现在 日 和 星期 日中5L 表示 在最后的星期四触发 W： 工作日 只能出现在 日 在离指定日期的最近有效工作日触发 #：表示每个月的第几个星期几 C：关联日历 异步多线程实现 ​ 两步： 启动类 $$ $$"},{"title":"jvm","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/JVM/","categories":[["java","/categories/java/"]],"content":"JVMJVM内存结构 1方法区 ​ 存储一些类的东西。 2堆 ​ 通过new 关键字 创建的对象都会进入堆 ​ 有垃圾回收机制 ​ 需要考虑多线程 3虚拟机栈（JVM Stacks）每个线程运行时需要的内存 作用： 栈（由多个栈帧组成）：先进后出 栈帧（每个方法调用时需要的内存）：每个方法运行时需要的内存。 栈内存溢出 ​ 栈帧过多（递归过多） ​ 栈帧过大（参数实在是太多） ​ 4程序计数器（Program Counter Register）(寄存器实现) 作用:记住下一条jvm指令的地址 每个线程都有自己的程序计数器 唯一一个不会存在内存溢出的区 5本地方法栈 存放不是java代码的方法 执行引擎 解释器 即时编译器 垃圾回收 垃圾回收机制引用计数法 只要一个对象被其他对象引用，计数+1 +2 -1 -2 -3…. 被引用为0 视为垃圾 被回收 问题： 存在循环引用问题 可达性分析法 一个对象没有直接或间接被根对象（GC root）引用-&gt;视为垃圾，被回收 GC root对象: 固定的根对象包含： JVM stack：虚拟机栈(栈桢中本地变量表)中引用的对象，即所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数&#x2F;局部变量&#x2F;临时值。 native method stack：本地方法栈中JNI(即一般说的Native方法)中引用的对象 runtime constant pool：运行时常量池引用的对象，（如String字符串常量） static reference in method area：方法区中类静态属性 Class：方法区中Class对象 非固定的根对象：跨代引用的对象，比如老年代中某些对象引用了年轻代的对象的时候，这时候的老年代的某些对象也需要加入GC Roots 进行扫描。 四种引用 强引用：沿着GC root 引用对象能找到 这个对象 就不能回收 软引用：内存不够就回收，内存充足不回收 弱引用 要发生GC，一定被回收 虚引用 垃圾回收算法： 标记清除算法 先标记垃圾 -&gt; 占用空间清除 优点：速度快 缺点：容易产生内存碎片 标记整理算法 先标记垃圾 -&gt; 整理碎片，删除垃圾 优点：珏姐内存碎片 缺点：地址改变 复制算法 复制大小相等的内存区 -&gt; 将存活的对象 复制到 复制的内存中，并解决碎片化-&gt;交换引用 优点：占用双倍的内存孔家 分代回收 ​ 新生代： 伊甸园 幸存区 from 幸存区 to ​ 老年代 首先进入 e电源 -&gt; 不够时触发一次GC（Minor GC）-&gt;把 复制算法 把存活的对象放入 幸存区 to 寿命+1-&gt;将to -&gt; from 调换 第二次 ​ 。。。。 当寿命超过 阈值 时 放入 老年代 当老年代空间不足，先尝试触发 minor gc 如果空间还是不足 触发 full gc minor gc 和 full gc (时间更长)会引发 stop the word 停止用户线程 等到gc完成 ，再继续。 类加载机制"},{"title":"练习","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/streaml%E7%BB%83%E4%B9%A0/","categories":[["java","/categories/java/"]],"content":""},{"title":"redis","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/redis/","categories":[["中间件","/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"]],"content":"缓存1、缓存更新策略 内存淘汰 超时剔除 主动更新 说明 不用维护，利用redis淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新缓存。 给缓存数据添加TTL时间，到期后自动删除缓存。下次查询更新缓存 编写业务逻辑，在修改数据库的同时，更新缓存 一致性 差 一般 好 维护成本 无 低 高 主动更新策略 Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案（企业使用最多） 删除缓存还是更新缓存？ 更新缓存：每次更新数据库都更新缓存，无效写操作较多（×） 删除缓存：更新数据库时让缓存失效，查询时再更新缓存（√） 如何保证缓存与数据库的操作的同时成功或失败？ 单体系统，将缓存与数据库操作放在一个事务 分布式系统，利用TCC等分布式事务方案 应该具体操作缓存还是操作数据库，我们应当是先操作数据库，再删除缓存，原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。 先操作缓存还是先操作数据库？ 先删除缓存，再操作数据库 先操作数据库，再删除缓存（√） Read&#x2F;Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理 Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致 ​ 缓存穿透（请求的数据再缓存和数据库中都不存在） ​ 解决思路： 常见的解决方案有两种： 缓存空对象 优点：实现简单，维护方便 缺点： 额外的内存消耗 可能造成短期的不一致 布隆过滤（布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中， 假设布隆过滤器判断这个数据不存在，则直接返回 这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突 ） 优点：内存占用较少，没有多余key 缺点： 实现复杂 存在误判可能 缓存雪崩 （缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。） 解决方案： 给不同的Key的TTL添加随机值 利用Redis集群提高服务的可用性 给缓存业务添加降级限流策略 给业务添加多级缓存 ​ "},{"title":"spring","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/spring/","categories":[["框架相关","/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"]],"content":"Spring特点 方便解耦，简化开发 方便测试。（junit） 方便事务操作 AOP（面向切面编程）不修改源代码进行功能的增强。 底层使用动态代理 有接口情况 -&gt; 使用JDK动态代理 前置通知：MethodBeforeAdvice 后置通知：AfterReturningAdvice 环绕通知：MethodInterceptor 异常通知：ThrowsAdvice 无接口情况 使用CGLI动态代理 ​ IOC(控制反转)把创建对象的过程交给Spring管理。 spring提供IOC容器的两种方式(两个接口): Spring针对Bean管理中创建对象提供的注解 @Component @Service @Controller @Repository 属性注入提供注解 @Autowired 根据属性类型自动装配 @Resource 属性名称注入 属性类型注入 @Qualifier 属性名称注入 JdbcTemplate用的少。 事务(要么都成功，如果一个失败，全失败)(原理是AOP)&#x2F;&#x2F; 一般在业务逻辑层（Service） 事务四个特性（ACID） 原子性 -&gt; 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性 -&gt; 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。 隔离性 -&gt; 数据库允许多个并发事务同时对其数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 持久性 -&gt; 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 事务隔离级别 未提交读（Read uncommitted），最低的隔离级别，允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改。如果另一个事务回滚，那么当前事务读到的数据就是脏数据。 提交读（read committed），一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 可重复读（repeatable read），一个事务可能会遇到幻读（Phantom Read）的问题。幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 串行化（Serializable），最严格的隔离级别，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。虽然 Serializable 隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用 Serializable 隔离级别。 日志log4j"},{"title":"mybatis","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/mybatis/","categories":[["框架相关","/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"]],"content":"实体类 需要使用包装类（防止 NULL 的问题） #{}和 ${}的区别 #{}是会参与预编译处理。 ${}仅仅是字符替换。 批量删除if choose标签 多条件分支判断 select * from tbl_user02 and name = #{name} and email = #{email} and pwd = #{pwd} foreach标签循环标签 适用于批量添加、删除 和查询记录 set标签这个标签配合if标签一起用 一般用于修改语句 如果传递的参数为null 那么就不会修改该列的值 "},{"title":"集合","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/%E9%9B%86%E5%90%88/","categories":[["java","/categories/java/"]],"content":"title: 集合 date: 2022-01-07 22:53:43categories: java 集合1、ArrayList​ 数据结构 -&gt; 动态数组​ 特点： ​ 可以加入 null 多个 动态数组 线程不安全 ​ 1、扩容机制​ 首先默认创建方式 ​ ​ 接下来会执行 grow(); 方法 ​ 可以看到 第一次扩容大小为10，之后扩容为二进制 &gt;&gt; 1 + 原来数组的长度 (0.5 + 1)也就是 扩容为原来的1.5倍。 创建一个新的数组然后复制 （minCapacity - oldCapacity）与 二进制 &gt;&gt; 1 中取最大值。 2、删除机制​ 首先 对索引进行 筛选 如果 超过数据大小 抛异常：outOfBounds 1、int i &#x3D; list.size() - 1;i &gt;&#x3D; 0;i– for循环反向删除 ！！注意 list删除后，之前数据会向前移为，正向删除会出现一定的问题 3、iterator循环删除(不能这样使用) 源码分析 增删效率 改查效率 ArrayList 动态数组 较低 较高 LinkedList 双向链表 较高 较低 正确用法（推荐用法）： 2、LinkedList -&gt; 双向链表​ 特点： ​ 1、LinkedList维护了元素插入的时候的顺序; ​ 2、实现了Queue、Deque接口; ​ 3、是非线程安全的; ​ 4、适合删除操作，因为，删除不会发生移位; ​ 5、可以包含重复的元素; 3、set -&gt;常用 hashSet treeSet ​ 1、不允许重复，最多包含一个null值 ​ 2、无序 4、HashMap(数组+链表+红黑树) jdk1.8 1、扩容因子为什么默认为0.75f ​ ① 空间和时间 ​ "},{"title":"springboot","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/springboot/","categories":[["框架相关","/categories/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3/"]],"content":"概述 什么是 Spring Boot？Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方 案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动 器，开发者能快速上手。 Spring Boot 有哪些优点？Spring Boot 主要有如下优点： \\1. 容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入 门体验。2. 开箱即用，远离繁琐的配置。 \\3. 提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全 管理、运行数据监控、运行状况检查和外部化配置等。 \\4. 没有代码生成，也不需要XML配置。 \\5. 避免大量的 Maven 导入和各种版本冲突。 Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？ 启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心 注解，主要组合包含了以下 3 个注解： @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件 的功能。 @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配 置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。 @ComponentScan：Spring组件扫描。 配置 什么是 JavaConfig？Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的 纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在 于： （1）面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以 充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的 @Bean 方法等。 （2）减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。 但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发 人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从 技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多 人认为将JavaConfig 与 XML 混合匹配是理想的。（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。 Spring Boot 自动配置原理是什么？注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心， @EnableAutoConfiguration 给容器导入META-INF&#x2F;spring.factories 里定义 的自动配置类。 筛选有效的自动配置类。 每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置 功能 你如何理解 Spring Boot 配置加载顺序？在 Spring Boot 里面，可以使用以下几种方式来加载配置。 1）properties文件； 2）YAML文件； 3）系统环境变量； 4）命令行参数； 等等…… 什么是 YAML？YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件 相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构 化，而且更少混淆。可以看出 YAML 具有分层配置数据。 YAML 配置的优势在哪里 ?YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端， 都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底 有哪些优势呢？ \\1. 配置有序，在一些特殊的场景下，配置有序很关键 \\2. 支持数组，数组中的元素可以是基本数据类型也可以是对象 \\3. 简洁相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。 Spring Boot 是否可以使用 XML 配置 ?Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以 使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。 spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文 件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加 载一些远程配置文件的时侯。 spring boot 核心的两个配置文件： bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加 载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说 我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不 能被覆盖； application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。 什么是 Spring Profiles？ Spring Profiles 允许用户根据配置文件（dev， test，prod 等）来注册 bean。 因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文 档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。 Spring Boot 使得使用配置文件非常简单。 如何在自定义端口上运行 Spring Boot 应用程序？ 为了在自定义端口上运行 Spring Boot 应用程序，您可以在 application.properties 中指定端口。server.port &#x3D; 8090 安全****如何实现 Spring Boot 应用程序的安全性？ 为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依 赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展 WebSecurityConfigurerAdapter 并覆盖其方法。 比较一下 Spring Security 和 Shiro 各自的优缺点 ? 由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变 得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合， 单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点： \\1. Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级 的安全管理框架 \\2. Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单 \\3. Spring Security 功能强大；Shiro 功能简单 Spring Boot 中如何解决跨域问题 ? 跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无 法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我 们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问 题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通 过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现 在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解 决跨域问题。 1 @Configuration 2 public class CorsConfig implements WebMvcConfigurer { 3 4 @Override 5 public void addCorsMappings(CorsRegistry registry) { 6 registry.addMapping(“&#x2F;**”) 7 .allowedOrigins(“*”) 8 .allowCredentials(true)9 .allowedMethods(“GET”, “POST”, “PUT”, “DELETE”, “OPTIONS”) 10 .maxAge(3600); 11 } 12 13 } 项目中前后端分离部署，所以需要解决跨域的问题。 我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限 不符合时，直接返回给用户固定的json结果。 当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦 截器和跨域的顺序有问题，出现了跨域的现象。 我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果 我们把cors放在filter里，就可以优先于权限拦截器执行。 1 @Configuration 2 public class CorsConfig { 3 4 @Bean 5 public CorsFilter corsFilter() { 6 CorsConfiguration corsConfiguration &#x3D; new CorsConfiguration(); 7 corsConfiguration.addAllowedOrigin(“*”); 8 corsConfiguration.addAllowedHeader(“*”); 9 corsConfiguration.addAllowedMethod(“*”); 10 corsConfiguration.setAllowCredentials(true); 11 UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource &#x3D; new U rlBasedCorsConfigurationSource(); 12 urlBasedCorsConfigurationSource.registerCorsConfiguration(“&#x2F;**”, corsCo nfiguration); 13 return new CorsFilter(urlBasedCorsConfigurationSource); 14 } 15 16 } 什么是 CSRF 攻击？ CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的 Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不 是数据窃取，因为攻击者无法查看对伪造请求的响应。 监视器****Spring Boot 中的监视器是什么？ Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监 视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须 在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来 向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问 的REST 端点来检查状态。 如何在 Spring Boot 中禁用 Actuator 端点安全性？ 默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色 的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访 问时，才建议禁用安全性。 我们如何监视所有 Spring Boot 微服务？ Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关 应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常 运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开 应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微 服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理 这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之 上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。 整合第三方项目 什么是 WebSockets？ WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信 道。 1、WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发 送。 2、WebSocket 是全双工的 -客户端和服务器通信是相互独立的。 3、单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连 接。然后这个单一连接用于所有未来的通信4、Light -与 http 相比，WebSocket 消息数据交换要轻得多。 什么是 Spring Data ? Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有 如下特点： SpringData 项目支持 NoSQL 存储： \\1. MongoDB （文档数据库） \\2. Neo4j（图形数据库） \\3. Redis（键&#x2F;值存储） \\4. Hbase（列族数据库） SpringData 项目所支持的关系数据存储技术： \\1. JDBC \\2. JPA Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的， 就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么 样的逻辑。 什么是 Spring Batch？ Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要， 包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管 理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高 批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的 方式利用框架处理重要大量的信息。 什么是 FreeMarker 模板？ FreeMarker 是一个基于 Java 的模板引擎，最初专注于使用 MVC 软件架构进 行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。 程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用 freemarker 可以将这些结合起来，给出最终的输出页面。 如何集成 Spring Boot 和 ActiveMQ？对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配 置，并且不需要样板代码。 什么是 Apache Kafka？ Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的 发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。 什么是 Swagger？你用 Spring Boot 实现了它吗？ Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙 箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完 整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确 定义时，消费者可以使用最少量的实现逻辑来理解远程服务并与其进行交互。因 此，Swagger消除了调用服务时的猜测。 前后端分离，如何维护接口文档 ? 前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后 端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮 中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太 低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见 的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网 站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网 站就可以获取到最新的接口文档，非常方便。 其他 如何重新加载 Spring Boot 上的更改，而无需重新启动 服务器？Spring Boot项目如何热部署？ 这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入 式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它 有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更 改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功 能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。 它还提供 H2 数据库控制台以更好地测试应用程序。 1 2 org.springframework.boot 3 spring‐boot‐devtools 4 您使用了哪些 starter maven 依赖项？ 使用了下面的一些依赖项 spring-boot-starter-activemq spring-boot-starter-security 这有助于增加更少的依赖关系，并减少版本的冲突。 Spring Boot 中的 starter 到底是什么 ? 首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来 实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根 据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入 进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只 需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter spring-boot-starter-parent 有什么用 ? 我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要 有如下作用： \\1. 定义了 Java 编译版本为 1.8 。 \\2. 使用 UTF-8 格式编码。 \\3. 继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也 正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。 \\4. 执行打包操作的配置。 \\5. 自动化的资源过滤。6. 自动化的插件配置。 \\7. 针对 application.properties 和 application.yml 的资源过滤，包括通 过 profile 定义的不同环境的配置文件，例如 application\u0002 dev.properties 和 application-dev.yml。 Spring Boot 打成的 jar 和普通的 jar 有什么区别 ? Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java - jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依 赖了也无法使用其中的类。 Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。 普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \\BOOT-INF\\classes 目录下才是我们的代码，因 此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。 运行 Spring Boot 有哪几种方式？ 1）打包用命令或者放到容器中运行 2）用 Maven&#x2F; Gradle 插件运行 3）直接执行 main 方法运行 Spring Boot 需要独立的容器运行吗？ 可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。 开启 Spring Boot 特性有哪几种方式？ 1）继承spring-boot-starter-parent项目 2）导入spring-boot-dependencies项目依赖 如何使用 Spring Boot 实现异常处理？ Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们 通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。 如何使用 Spring Boot 实现分页和排序？ 使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分 页的传递给存储库方法。微服务中如何实现 session 共享 ? 在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立 部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经 常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上 的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的 代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简 便。 Spring Boot 中如何实现定时任务 ? 定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来 自 Spring 框架。 在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。 使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。 使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。"},{"title":"mysql","date":"2023-03-07T16:00:00.000Z","url":"/2023/03/08/mysql/","categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"mysql1、索引（高效获取数据） 调优B+树innodb 中索引用的B+树 ①mysql如何实现索引机制 MySQL中索引分三类：B+树索引、Hash索引、全文索引 ② InnoDB索引与MyISAM索引实现的区别是什么？ ​ InnoDB：存储时数据和索引放在一起。MyISAM索引单独放一个文件 ​ 2、架构2、事务3、日志4、开发sql语法基础distinct 去重 IFNULL 查询常数 分页 连接笛卡尔积（交叉连接） 1、左连接(left join) – 取 左表 + 共同数据（） 2、右连接 right join – 右表 + 共同数据 3、内连接(inner join) inner 可省略 – AB表的交集 4、 union：会对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序。 5、union all：对两个结果集进行并集操作，包括重复行，不会对结果进行排序。 函数 聚合函数AVG SUM MIN MAX COUNT GROUP BY having 1. 当在一个SQL中同时使用where和group by和having子句时，其执行顺序为：where&gt;group by&gt;having。 2. where子句作用于表或者视图，having子句作用于组，having子句必须作用在group by之后。 视图一个或多个表的数据的逻辑显示，不存储数据 面经"},{"title":"函数式编程","date":"2022-01-07T14:53:43.000Z","url":"/2022/01/07/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","categories":[["java","/categories/java/"]],"content":"函数式编程-Stream流1. 概述1.1 优点 大数量下处理集合效率高 代码可读性高 1.2 函数式编程思想1.2.1 概念​ 面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。 1.2.2 优点 代码简洁，开发快速 接近自然语言，易于理解 易于”并发编程” 2. Lambda表达式2.1 概述​ Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。 2.2 核心原则2. 3 基本格式 例一我们在创建线程并启动时可以使用匿名内部类的写法： 可以使用Lambda的格式对其进行修改。修改后如下： 例二:现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。 Lambda写法： 例三：现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。 Lambda写法： 例四：现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。 Lambda写法： 例五：现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。 Lambda写法： 2.4 省略规则 参数类型可以省略 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略 方法只有一个参数时小括号可以省略 以上这些规则都记不住也可以省略不记 3. Stream流3.1 概述​ Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。 3.2 案例数据准备 3.3 快速入门3.3.1 需求​ 我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。 3.3.2 实现 3.4 常用操作3.4.1 创建流单列集合： 集合对象.stream() 数组：Arrays.stream(数组) 或者使用Stream.of来创建 双列集合：转换成单列集合后再创建 3.4.2 中间操作filter​ 可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。 例如： ​ 打印所有姓名长度大于1的作家的姓名 map​ 可以把对流中的元素进行计算或转换。 例如： ​ 打印所有作家的姓名 distinct​ 可以去除流中的重复元素。 例如： ​ 打印所有作家的姓名，并且要求其中不能有重复元素。 注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。 sorted​ 可以对流中的元素进行排序。 例如： ​ 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。 注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。 ​ limit​ 可以设置流的最大长度，超出的部分将被抛弃。 例如： ​ 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。 skip​ 跳过流中的前n个元素，返回剩下的元素 例如： ​ 打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。 flatMap​ map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。 例一： ​ 打印所有书籍的名字。要求对重复的元素进行去重。 例二： ​ 打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情 3.4.3 终结操作forEach​ 对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。 例子： ​ 输出所有作家的名字 count​ 可以用来获取当前流中元素的个数。 例子： ​ 打印这些作家的所出书籍的数目，注意删除重复元素。 max&amp;min​ 可以用来或者流中的最值。 例子： ​ 分别获取这些作家的所出书籍的最高分和最低分并打印。 collect​ 把当前流转换成一个集合。 例子： ​ 获取一个存放所有作者名字的List集合。 ​ 获取一个所有书名的Set集合。 ​ 获取一个Map集合，map的key为作者名，value为List 查找与匹配anyMatch​ 可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。 例子： ​ 判断是否有年龄在29以上的作家 allMatch​ 可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。 例子： ​ 判断是否所有的作家都是成年人 noneMatch​ 可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false 例子： ​ 判断作家是否都没有超过100岁的。 findAny​ 获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。 例子： ​ 获取任意一个年龄大于18的作家，如果存在就输出他的名字 findFirst​ 获取流中的第一个元素。 例子： ​ 获取一个年龄最小的作家，并输出他的姓名。 reduce归并​ 对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作） ​ reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。 ​ reduce两个参数的重载形式内部的计算方式如下： ​ 其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。 例子： ​ 使用reduce求所有作者年龄的和 ​ 使用reduce求所有作者中年龄的最大值 ​ 使用reduce求所有作者中年龄的最小值 ​ reduce一个参数的重载形式内部的计算 ​ 如果用一个参数的重载方法去求最小值代码如下： 3.5 注意事项 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的） 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用） 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的） 4. Optional4.1 概述​ 我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。 ​ 例如： ​ 尤其是对象中的属性还是一个对象的情况下。这种判断会更多。 ​ 而过多的判断语句会让我们的代码显得臃肿不堪。 ​ 所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。 ​ 并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。 4.2 使用4.2.1 创建对象​ Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。 ​ 我们一般使用Optional的静态方法ofNullable来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。 ​ 你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。 ​ 而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。 ​ 如果你确定一个对象不是空的则可以使用Optional的静态方法of来把数据封装成Optional对象。 ​ 但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果） ​ 如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用Optional的静态方法empty来进行封装。 ​ ​ 所以最后你觉得哪种方式会更方便呢？ofNullable 4.2.2 安全消费值​ 我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其ifPresent方法对来消费其中的值。 ​ 这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。 ​ 例如,以下写法就优雅的避免了空指针异常。 4.2.3 获取值​ 如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。 4.2.4 安全获取值​ 如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。 orElseGet 获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。 orElseThrow 获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。 4.2.5 过滤​ 我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。 4.2.6 判断​ 我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，更推荐使用ifPresent方法。 4.2.7 数据转换​ Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。 例如我们想获取作家的书籍集合。 5. 函数式接口5.1 概述​ 只有一个抽象方法的接口我们称之为函数接口。 ​ JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。 5.2 常见函数式接口 ​ Consumer 消费接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。 ​ Function 计算转换接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回 ​ Predicate 判断接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果 ​ Supplier 生产型接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回 5.3 常用的默认方法 and 我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&amp;&amp;来拼接两个判断条件 例如： 打印作家中年龄大于17并且姓名的长度大于1的作家。 or 我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。 例如： 打印作家中年龄大于17或者姓名的长度小于2的作家。 negate Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反 例如： 打印作家中年龄不大于17的作家。 6. 方法引用​ 我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。 6.1 推荐用法​ 我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。 ​ 当我们方法引用使用的多了慢慢的也可以直接写出方法引用。 6.2 基本格式​ 类名或者对象名::方法名 6.3 语法详解(了解)6.3.1 引用类的静态方法​ 其实就是引用类的静态方法 格式 使用前提​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个类的静态方法，并且我们把要重写的抽象方法中所有的参数都按照顺序传入了这个静态方法中，这个时候我们就可以引用类的静态方法。 ​ 例如： 如下代码就可以用方法引用进行简化 注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。 优化后如下： 6.3.2 引用对象的实例方法格式 使用前提​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个对象的成员方法，并且我们把要重写的抽象方法中所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用对象的实例方法 例如： 优化后： 6.3.4 引用类的实例方法格式 使用前提​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了第一个参数的成员方法，并且我们把要重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中，这个时候我们就可以引用类的实例方法。 例如： 优化后如下： 6.3.5 构造器引用​ 如果方法体中的一行代码是构造器的话就可以使用构造器引用。 格式 使用前提​ 如果我们在重写方法的时候，方法体中只有一行代码，并且这行代码是调用了某个类的构造方法，并且我们把要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中，这个时候我们就可以引用构造器。 例如： 优化后： 7. 高级用法基本数据类型优化​ 我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。 ​ 即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。 ​ 所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。 ​ 例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等。 并行流​ 当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。 ​ parallel方法可以把串行流转换成并行流。 ​ 也可以通过parallelStream直接获取并行流对象。 8. 练习 "}]